#!/usr/bin/env python

# -*- coding: utf-8 -*-

# Author: Milan Nikolic <gen2brain@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import zipfile
import tempfile
import shutil
from subprocess import Popen, PIPE
from optparse import OptionParser

try:
    if os.path.isdir(os.path.join(".","src")) and os.path.isfile(
            os.path.join(".","setup.py")):
        from src import utils
        from src.debug import log
    else:
        from comicutils import utils
        from comicutils.debug import log
except ImportError:
    sys.stderr.write("Can't import utils module\r\nExiting...\r\n")
    sys.exit(1)

APP = {}
BINDIR = os.path.join(sys.path[0], 'bin')

for cmd in ['rar', 'mogrify', 'convert', 'ppmtobmp']:
    if os.name == 'nt':
        command = os.path.join(BINDIR, cmd)
        if os.path.isfile("%s.exe" % command):
            APP[cmd] = command
        else:
            log.Error("Could not find '%s' executable." % command)
    else:
        command = utils.which(cmd)
        if command:
            APP[cmd] = command
        else:
            log.Error("Could not find '%s' executable." % cmd)

def unpack_archive(filepath, filetype, filename):
    if filetype == 'ZIP':
        try:
            tempdir = tempfile.mkdtemp(filename)
            zip = zipfile.ZipFile(filepath, 'r')
            zip.extractall(tempdir)
            return tempdir
        except Exception, err:
            log.Warn('Error extracting %s file %s: %s' % (
                filetype, filepath, str(err)))
    elif filetype == 'RAR':
        try:
            tempdir = tempfile.mkdtemp(filename)
            p = Popen([APP['rar'], 'x', filepath, tempdir],
                    stdin=PIPE, stdout=PIPE, stderr=PIPE)
            out = p.communicate()
            p.wait()
            if out[1] != '':
                sys.stderr.write('Error extracting %s file %s: %s' % (
                    filetype, filepath, out[1]))
            else:
                return tempdir
        except Exception, err:
            log.Warn('Error extracting %s file %s: %s' % (
                filetype, filepath, str(err)))
    return None

def pack_archive(tempdir, filetype, filepath):
    cwd = os.getcwd()
    os.chdir(tempdir)
    basename = os.path.basename(filepath)
    if filetype == 'ZIP':
        try:
            zip = zipfile.ZipFile(filepath, 'w', zipfile.ZIP_DEFLATED)
            for dirpath, dirnames, filenames in os.walk(tempdir):
                for filename in filenames:
                    relpath = os.path.relpath(os.path.join(dirpath, filename))
                    zip.write(relpath)
            zip.close()
            os.chdir(cwd)
            return True
        except Exception, err:
            log.Warn('Error packing %s file %s: %s' % (
                filetype, basename, str(err)))
    elif filetype == 'RAR':
        try:
            p = Popen([APP['rar'], 'a', '-r', filepath, '*'],
                    stdin=PIPE, stdout=PIPE, stderr=PIPE)
            out = p.communicate()
            p.wait()
            if out[1] != '':
                log.Warn('Error packing %s file %s: %s' % (
                    filetype, basename, out[1]))
            else:
                os.chdir(cwd)
                return True
        except Exception, err:
            log.Warn('Error packing %s file %s: %s' % (
                filetype, basename, str(err)))
    return False

def image_scale(fullpath, opts):
    p = Popen([APP['mogrify'], '-quality', str(opts.quality),
        '-scale', str(opts.scale), fullpath],
            stdin=PIPE, stdout=PIPE, stderr=PIPE)
    out = p.communicate()
    p.wait()
    if out[1] != '':
        log.Warn('Error converting file %s: %s' % (fullpath, out[1]))
        return False
    return True

def image_bmp(file, opts):
    filename, fullpath, basename, fileext, cover = file
    if opts.cover and filename == cover:
        depth, colors = 8, 256
    elif opts.BMP:
        depth, colors = 8, 256
    elif opts.bmp:
        depth, colors = 4, 16
    try:
        convert = Popen([APP['convert'], fullpath, '+matte',
            '-scale', str(opts.scale),
            '-depth', str(depth), '-colors', str(colors), 'ppm:-'],
                stdin=PIPE, stdout=PIPE, stderr=PIPE)
        bmp = Popen([APP['ppmtobmp'], '-bpp', str(depth)],
                stdin=convert.stdout, stdout=PIPE, stderr=PIPE)
        lines = bmp.stdout.readlines()
        if len(lines) > 0:
            newpath = os.path.join(
                    os.path.dirname(fullpath), '%s.bmp' % basename)
            newfile = open(newpath, 'w')
            newfile.writelines(lines)
            newfile.close()
            if fileext.lower() != '.bmp':
                os.unlink(fullpath)
        return True
    except OSError:
        newfile.close()
        return False

def image_jpeg(file, opts):
    filename, fullpath, basename, fileext, cover = file
    newpath = os.path.join(
            os.path.dirname(fullpath), '%s.jpg' % basename)
    p = Popen([APP['convert'], fullpath, '-quality', str(opts.quality),
        '-scale', str(opts.scale), newpath],
            stdin=PIPE, stdout=PIPE, stderr=PIPE)
    out = p.communicate()
    p.wait()
    if out[1] != '':
        log.Warn('Error converting file %s: %s' % (fullpath, out[1]))
        return False
    if fileext.lower() != '.jpg':
        os.unlink(fullpath)
    return True

def image_png(file, opts):
    filename, fullpath, basename, fileext, cover = file
    newpath = os.path.join(
            os.path.dirname(fullpath), '%s.png' % basename)
    p = Popen([APP['convert'], fullpath, '-quality', str(opts.quality),
        '-scale', str(opts.scale), newpath],
            stdin=PIPE, stdout=PIPE, stderr=PIPE)
    out = p.communicate()
    p.wait()
    if out[1] != '':
        log.Warn('Error converting file %s: %s' % (fullpath, out[1]))
        return False
    if fileext.lower() != '.png':
        os.unlink(fullpath)
    return True

def convert_images(tempdir, opts):
    exclude = [] if not opts.exclude else opts.exclude
    images = utils.get_images(tempdir)
    maxrecords = len(images)
    try:
        for filenum, file in enumerate(images):
            filename, fullpath, basename, fileext, cover = file
            if str(filenum) in exclude:
                continue
            if opts.nocover and filename == cover:
                continue

            if opts.bmp or opts.BMP:
                image_bmp(file, opts)
            elif opts.jpeg:
                image_jpeg(file, opts)
            elif opts.png:
                image_png(file, opts)
            elif opts.scale != '100%' or opts.quality != '75':
                image_scale(fullpath, opts)

            if opts.verbose:
                percent = float(filenum) / float(maxrecords) * 100
                sys.stderr.write('Converting images [%d%%]\r' % int(percent))
        return True
    except Exception, err:
        log.Warn('Error converting file %s: %s' % (tempdir, str(err)))
    return False

def exclude_callback(option, opt, value, parser):
    setattr(parser.values, option.dest, value.split(','))

def main(rootpath, opts):
    if opts.outdir:
        if not os.path.isdir(opts.outdir):
            log.Error('Error: %s is not a directory' % (opts.outdir))

    try:
        filenum = 1
        comics = utils.get_comics(rootpath, opts.size)
        total = len(comics)

        for file in comics:
            filename, basename, fileext, filedir, fullpath, filetype, filesize, filemtime, fileuri = file

            if opts.outdir:
                convdir = os.path.realpath(opts.outdir)
            else:
                convdir = os.path.join(filedir, '_converted')

            if opts.verbose:
                sys.stderr.write('File %d of %d\n' % (filenum, total))
                sys.stderr.write('Proccessing %s archive %s (%sMB)\n' % (
                    filetype, fullpath, filesize/(1024*1024)))
                sys.stderr.write('Unpacking...\r')

            tempdir = unpack_archive(fullpath, filetype, filename)
            if tempdir is not None:
                if opts.verbose:
                    sys.stderr.write('File %s unpacked\n' % (filename))

                if convert_images(tempdir, opts):
                    if opts.verbose:
                        sys.stderr.write('File %s converted\n' % (filename))
                    if not opts.outdir and not os.path.isdir(convdir):
                        os.mkdir(convdir)
                    if opts.verbose:
                        sys.stderr.write('Packing... \r')

                    if opts.rar:
                        filetype = 'RAR'
                        filename = '%s.cbr' % basename
                    elif opts.zip:
                        filetype = 'ZIP'
                        filename = '%s.cbz' % basename

                    filepath = os.path.join(convdir, filename)
                    if pack_archive(tempdir, filetype, filepath):
                        if opts.verbose:
                            sys.stderr.write('File %s packed (%sMB)\n\n' % (
                                filepath, os.path.getsize(filepath)/(1024*1024) ))
                        shutil.rmtree(tempdir)
            filenum += 1
    except KeyboardInterrupt:
        pass
    except Exception, err:
        if tempdir:
            shutil.rmtree(tempdir)
        log.Error('Error: %s %s' % (str(type(err)), str(err)))

if __name__ == '__main__':
    usage = 'usage: %prog <options> <file or dir>'
    parser = OptionParser(usage=usage)
    parser.add_option('-s', '--scale', action='store', dest='scale', type='string', default='100%',
            help='image geometry (default %default)', metavar='<arg>')
    parser.add_option('-q', '--quality', action='store', dest='quality', type='string', default='75',
            help='image quality (default %default, used with --jpeg, --png and --scale)', metavar='<arg>')
    parser.add_option('-o', '--outdir', action='store', dest='outdir', type='string', default=None,
            help='output directory (default is _converted in proccesed directory)', metavar='<arg>')
    parser.add_option('-m', '--size', action='store', dest='size', type='int', default=None,
            help='process only files larger then size (in MB)', metavar='<arg>')
    parser.add_option('-b', '--bmp-4', action='store_true', dest='bmp', default=False,
            help='convert images to 4bit BMP format', metavar='<arg>')
    parser.add_option('-c', '--cover', action='store_true', dest='cover', default=False,
            help='convert cover to 8bit BMP instead of 4bit (used with --bmp-4)', metavar='<arg>')
    parser.add_option('-n', '--no-cover', action='store_true', dest='nocover', default=False,
            help='exclude cover', metavar='<arg>')
    parser.add_option('-B', '--bmp-8', action='store_true', dest='BMP', default=False,
            help='convert images to 8bit BMP format', metavar='<arg>')
    parser.add_option('-j', '--jpeg', action='store_true', dest='jpeg', default=False,
            help='convert images to JPEG format', metavar='<arg>')
    parser.add_option('-p', '--png', action='store_true', dest='png', default=False,
            help='convert images to PNG format', metavar='<arg>')
    parser.add_option('-e', '--exclude', action='callback', dest='exclude', type='string', callback=exclude_callback,
            help='list of images to exclude (0,2,13)', metavar='<arg>')
    parser.add_option('-r', '--rar', action='store_true', dest='rar', default=False,
            help='convert archive to RAR format', metavar='<arg>')
    parser.add_option('-z', '--zip', action='store_true', dest='zip', default=False,
            help='convert archive to ZIP format', metavar='<arg>')
    parser.add_option('-v', '--verbose', action='store_true', dest='verbose', default=True,
            help='verbose (default)')
    parser.add_option('-Q', '--quiet', action='store_false', dest='verbose',
            help='quiet')
    (opts, args) = parser.parse_args()

    try:
        rootpath = os.path.realpath(args[0])
    except:
        parser.print_help()
        sys.exit(1)

    main(rootpath, opts)
